
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_survival_analysis.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_survival_analysis.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_survival_analysis.py:


========================================================
Comparison of lifelines with skglm for survival analysis
========================================================
This example shows that ``skglm`` fits a Cox model exactly as ``lifelines`` but with
x100 less time.

.. GENERATED FROM PYTHON SOURCE LINES 12-18

Data
----

Let's first generate synthetic data on which to run the Cox estimator,
using ``skglm`` data utils.


.. GENERATED FROM PYTHON SOURCE LINES 18-29

.. code-block:: Python

    from skglm.utils.data import make_dummy_survival_data

    n_samples, n_features = 500, 100
    X, y = make_dummy_survival_data(
        n_samples, n_features,
        normalize=True,
        random_state=0
    )

    tm, s = y[:, 0], y[:, 1]








.. GENERATED FROM PYTHON SOURCE LINES 30-37

The synthetic data has the following properties:

* ``X`` is the matrix of predictors, generated using standard normal distribution with Toeplitz covariance.
* ``tm`` is the vector of occurrence times which follows a Weibull(1) distribution
* ``s`` indicates the observations censorship and follows a Bernoulli(0.5) distribution

Let's inspect the data quickly:

.. GENERATED FROM PYTHON SOURCE LINES 37-54

.. code-block:: Python

    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(
        1, 3,
        figsize=(6, 2),
        tight_layout=True,
    )

    dists = (tm, s, X[:, 5])
    axes_title = ("times", "censorship", "fifth predictor")

    for idx, (dist, name) in enumerate(zip(dists, axes_title)):
        axes[idx].hist(dist, bins="auto")
        axes[idx].set_title(name)

    _ = axes[0].set_ylabel("count")




.. image-sg:: /auto_examples/images/sphx_glr_plot_survival_analysis_001.png
   :alt: times, censorship, fifth predictor
   :srcset: /auto_examples/images/sphx_glr_plot_survival_analysis_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 55-62

Fitting the Cox Estimator
-------------------------

After generating the synthetic data, we can now fit a L1-regularized Cox estimator.
Todo so, we need to combine a Cox datafit and a :math:`\ell_1` penalty
and solve the resulting problem using skglm Proximal Newton solver ``ProxNewton``.
We set the intensity of the :math:`\ell_1` regularization to ``alpha=1e-2``.

.. GENERATED FROM PYTHON SOURCE LINES 62-83

.. code-block:: Python

    from skglm.datafits import Cox
    from skglm.penalties import L1
    from skglm.solvers import ProxNewton

    from skglm.utils.jit_compilation import compiled_clone

    # regularization intensity
    alpha = 1e-2

    # skglm internals: init datafit and penalty
    datafit = compiled_clone(Cox())
    penalty = compiled_clone(L1(alpha))

    datafit.initialize(X, y)

    # init solver
    solver = ProxNewton(fit_intercept=False, max_iter=50)

    # solve the problem
    w_sk = solver.solve(X, y, datafit, penalty)[0]








.. GENERATED FROM PYTHON SOURCE LINES 84-85

For this data a regularization value a relatively sparse solution is found:

.. GENERATED FROM PYTHON SOURCE LINES 85-90

.. code-block:: Python

    print(
        "Number of nonzero coefficients in solution: "
        f"{(w_sk != 0).sum()} out of {len(w_sk)}."
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of nonzero coefficients in solution: 66 out of 100.




.. GENERATED FROM PYTHON SOURCE LINES 91-93

Let's solve the problem with ``lifelines`` through its ``CoxPHFitter``
estimator and compare the objectives found by the two packages.

.. GENERATED FROM PYTHON SOURCE LINES 93-109

.. code-block:: Python

    import numpy as np
    import pandas as pd
    from lifelines import CoxPHFitter

    # format data
    stacked_y_X = np.hstack((y, X))
    df = pd.DataFrame(stacked_y_X)

    # fit lifelines estimator
    lifelines_estimator = CoxPHFitter(penalizer=alpha, l1_ratio=1.).fit(
        df,
        duration_col=0,
        event_col=1
    )
    w_ll = lifelines_estimator.params_.values








.. GENERATED FROM PYTHON SOURCE LINES 110-111

Check that both solvers find solutions having the same objective value:

.. GENERATED FROM PYTHON SOURCE LINES 111-117

.. code-block:: Python

    obj_sk = datafit.value(y, w_sk, X @ w_sk) + penalty.value(w_sk)
    obj_ll = datafit.value(y, w_ll, X @ w_ll) + penalty.value(w_ll)

    print(f"Objective skglm: {obj_sk:.6f}")
    print(f"Objective lifelines: {obj_ll:.6f}")
    print(f"Difference: {(obj_sk - obj_ll):.2e}")




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Objective skglm: 2.494576
    Objective lifelines: 2.494576
    Difference: 1.47e-10




.. GENERATED FROM PYTHON SOURCE LINES 118-119

We can do the same to check how close the two solutions are.

.. GENERATED FROM PYTHON SOURCE LINES 119-121

.. code-block:: Python

    print(f"Euclidean distance between solutions: {np.linalg.norm(w_sk - w_ll):.3e}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Euclidean distance between solutions: 3.373e-04




.. GENERATED FROM PYTHON SOURCE LINES 122-129

Timing comparison
-----------------

Now that we checked that both ``skglm`` and ``lifelines`` yield the same results,
let's compare their execution time. To get the evolution of the suboptimality
(objective - optimal objective) we run both estimators with increasing number of
iterations.

.. GENERATED FROM PYTHON SOURCE LINES 129-179

.. code-block:: Python

    import time
    import warnings

    warnings.filterwarnings('ignore')

    # where to save records
    records = {
        "skglm": {"times": [], "objs": []},
        "lifelines": {"times": [], "objs": []},
    }

    # time skglm
    max_runs = 20
    for n_iter in range(1, max_runs + 1):
        solver.max_iter = n_iter

        start = time.perf_counter()
        w = solver.solve(X, y, datafit, penalty)[0]
        end = time.perf_counter()

        records["skglm"]["objs"].append(
            datafit.value(y, w, X @ w) + penalty.value(w)
        )
        records["skglm"]["times"].append(end - start)

    # time lifelines
    max_runs = 50
    for n_iter in list(range(10)) + list(range(10, max_runs + 1, 5)):
        start = time.perf_counter()
        lifelines_estimator.fit(
            df,
            duration_col=0,
            event_col=1,
            fit_options={"max_steps": n_iter},
        )
        end = time.perf_counter()

        w = lifelines_estimator.params_.values

        records["lifelines"]["objs"].append(
            datafit.value(y, w, X @ w) + penalty.value(w)
        )
        records["lifelines"]["times"].append(end - start)


    # cast records as numpy array
    for idx, label in enumerate(("skglm", "lifelines")):
        for metric in ("objs", "times"):
            records[label][metric] = np.asarray(records[label][metric])








.. GENERATED FROM PYTHON SOURCE LINES 180-182

Results
-------

.. GENERATED FROM PYTHON SOURCE LINES 182-202

.. code-block:: Python


    fig, ax = plt.subplots(1, 1, tight_layout=True, figsize=(6, 3))
    solvers = ("skglm", "lifelines")

    optimal_obj = min(records[solver]["objs"].min() for solver in solvers)

    # plot evolution of suboptimality
    for solver in solvers:
        ax.semilogy(
            records[solver]["times"],
            records[solver]["objs"] - optimal_obj,
            label=solver,
            marker='o',
        )
    ax.legend()
    ax.set_title("Time to fit a Cox model")

    ax.set_ylabel("objective suboptimality")
    _ = ax.set_xlabel("time in seconds")




.. image-sg:: /auto_examples/images/sphx_glr_plot_survival_analysis_002.png
   :alt: Time to fit a Cox model
   :srcset: /auto_examples/images/sphx_glr_plot_survival_analysis_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 203-205

According to printed ratio, using ``skglm`` we get the same result as ``lifelines``
with more than x100 less time!

.. GENERATED FROM PYTHON SOURCE LINES 205-208

.. code-block:: Python

    speed_up = records["lifelines"]["times"][-1] / records["skglm"]["times"][-1]
    print(f"speed up ratio: {speed_up:.0f}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    speed up ratio: 794




.. GENERATED FROM PYTHON SOURCE LINES 209-217

Efron estimate
--------------

The previous results, namely closeness of solutions and timings,
can be extended to the case of handling tied observation with the Efron estimate.

Let's start by generating data with tied observations. This can be achieved
by passing in a ``with_ties=True`` to ``make_dummy_survival_data`` function.

.. GENERATED FROM PYTHON SOURCE LINES 217-228

.. code-block:: Python

    X, y = make_dummy_survival_data(
        n_samples, n_features,
        normalize=True,
        with_ties=True,
        random_state=0
    )
    tm, s = y[:, 0], y[:, 1]

    # check the data has tied observations
    print(f"Number of unique times {len(np.unique(tm))} out of {n_samples}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of unique times 51 out of 500




.. GENERATED FROM PYTHON SOURCE LINES 229-231

It is straightforward to fit an :math:`\ell_1` Cox estimator with the Efron estimate.
We only need to pass in ``use_efron=True`` to the ``Cox`` datafit.

.. GENERATED FROM PYTHON SOURCE LINES 231-240

.. code-block:: Python


    # ensure using Efron estimate
    datafit = compiled_clone(Cox(use_efron=True))
    datafit.initialize(X, y)

    # solve the problem
    solver = ProxNewton(fit_intercept=False, max_iter=50)
    w_sk = solver.solve(X, y, datafit, penalty)[0]








.. GENERATED FROM PYTHON SOURCE LINES 241-242

Again a relatively sparse solution is found:

.. GENERATED FROM PYTHON SOURCE LINES 242-247

.. code-block:: Python

    print(
        "Number of nonzero coefficients in solution: "
        f"{(w_sk != 0).sum()} out of {len(w_sk)}."
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of nonzero coefficients in solution: 82 out of 100.




.. GENERATED FROM PYTHON SOURCE LINES 248-249

Let's do the same with ``lifelines`` and compare the results

.. GENERATED FROM PYTHON SOURCE LINES 249-273

.. code-block:: Python


    # format data
    stacked_tm_s_X = np.hstack((tm[:, None], s[:, None], X))
    df = pd.DataFrame(stacked_tm_s_X)

    # fit lifelines estimator on the new data
    lifelines_estimator = CoxPHFitter(penalizer=alpha, l1_ratio=1.).fit(
        df,
        duration_col=0,
        event_col=1
    )
    w_ll = lifelines_estimator.params_.values

    # Check that both solvers find solutions with the same objective value
    obj_sk = datafit.value(y, w_sk, X @ w_sk) + penalty.value(w_sk)
    obj_ll = datafit.value(y, w_ll, X @ w_ll) + penalty.value(w_ll)

    print(f"Objective skglm: {obj_sk:.6f}")
    print(f"Objective lifelines: {obj_ll:.6f}")
    print(f"Difference: {(obj_sk - obj_ll):.2e}")

    # Check that both solutions are close
    print(f"Euclidean distance between solutions: {np.linalg.norm(w_sk - w_ll):.3e}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Objective skglm: 2.501289
    Objective lifelines: 2.501289
    Difference: -1.59e-09
    Euclidean distance between solutions: 4.046e-04




.. GENERATED FROM PYTHON SOURCE LINES 274-275

Finally, let's compare the timings of both solvers

.. GENERATED FROM PYTHON SOURCE LINES 275-300

.. code-block:: Python


    # time skglm
    start = time.perf_counter()
    solver.solve(X, y, datafit, penalty)[0]
    end = time.perf_counter()

    total_time_skglm = end - start

    # time lifelines
    lifelines_estimator = CoxPHFitter(penalizer=alpha, l1_ratio=1.)

    start = time.perf_counter()
    lifelines_estimator.fit(
        df,
        duration_col=0,
        event_col=1
    )
    end = time.perf_counter()

    total_time_lifelines = end - start

    # deduce speed up ratio
    speed_up = total_time_lifelines / total_time_skglm
    print(f"speed up ratio: {speed_up:.0f}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    speed up ratio: 687




.. GENERATED FROM PYTHON SOURCE LINES 301-303

As shown by the last print, we still preserve the x100 ratio speed up
even for the Efron estimate.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 55.453 seconds)


.. _sphx_glr_download_auto_examples_plot_survival_analysis.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_survival_analysis.ipynb <plot_survival_analysis.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_survival_analysis.py <plot_survival_analysis.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_survival_analysis.zip <plot_survival_analysis.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
